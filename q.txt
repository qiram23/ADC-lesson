Задача № 1 "Простейший АЦП"
Идея: бесконечно определять число, эквивалентное напряжению сигнала от Troyka-модуля, используя последовательный перебор напряжений на ЦАП и сигнал от компаратора.
Написать скрипт, в котором будет бесконечно вызываться функция adc(), в теле которой происходит последовательный перебор чисел от 0 до 255, подача текущего сигнала на ЦАП и сравнение сигнала со значением с компаратора на каждой итерации. В момент, когда на компараторе изменится состояние, то есть когда сигнал от ЦАП станет больше, чем от потенциометра, закончить перебор и вывести найденное значение.

При запуске скрипта в терминал бесконечно печатается только то напряжение (и эквивалентное ему десятичное число от 0 до 255), которое соответствует сигналу от Troyka-модуля. Пример вывода:

> Digital value: 251, Analog value: 3.2 V

Критерий готовности: при изменении потенциала на Troyka-модуле (то есть при вращении ручки потенциометра) в терминал выводится новое число, пропорциональное углу поворота ручки.
Требования к оформлению: использовать конструкцию  try-finally, функцию decimal2binary(decimal) (переводит десятичное число в двоичное) и dec2dac(decimal) (принимает десятичное число, подает двоичный код на входы ЦАП)
Задача № 2 "АЦП последовательного приближения или АЦП с поразрядным уравновешиванием"
Идея: усовершенствовать предыдущий скрипт, используя для подбора эквивалентного напряжения алгоритм бинарного поиска.
Изменить только функцию adc(), чтобы АЦП преобразовывал любой аналоговый сигнал в цифровой за 8 шагов. На каждом шаге определяется по одному биту искомого цифрового значения, начиная от СЗР (Старшего Значащего Разряда) и заканчивая МЗР (Младшим Значащим Разрядом). Последовательность действий по определению очередного бита заключается в следующем. На вспомогательном ЦАП выставляется аналоговое значение, образованное из битов, уже определённых на предыдущих шагах; бит, который должен быть определён на этом шаге, выставляется в 1, более младшие биты установлены в 0. Полученное на вспомогательном ЦАП значение сравнивается со значением с компаратора. Если значение этого входного сигнала больше значения на вспомогательном ЦАП, то определяемый бит получает значение 1, в противном случае 0. Таким образом, определение итогового цифрового значения напоминает двоичный поиск.

Критерий готовности: время получения цифрового сигнала (почти) не зависит от значения входного напряжения.


Требования к оформлению: использовать конструкцию  try-finally, функцию decimal2binary(decimal) (переводит десятичное число в двоичное) и dec2dac(decimal) (принимает десятичное число, подает двоичный код на входы ЦАП)
Задача № 3 "Громкость"
Идея: зажигать светодиоды в области LEDS, чтобы отображать состояние потенциометра (аналог индикатора уровня громкости на устройствах - volume bar).
Использовать функцию adc() из предыдущего задания. В блоке try в бесконечном цикле считывать значение с АЦП, ставить ему в соответствие список из нулей и единиц, который подавать на пины в область LEDS.

Нужно самостоятельно придумать логику, как сопоставлять числа от 0 до 256 с девятью возможными вариантами списка (все нули/ единица в нулевом разряде/ единицы в нулевом и первом разряде/ единицы в нулевом, первом и втором разряде ... единицы во всех разрядах), который в дальнейшем подается на пины. Для этого можно использовать функцию math.ceil() и побитовый сдвиг, но это не обязательное требование.

Критерий готовности: при максимальном напряжении на потенциометре горят все 8 светодиодов, при половине — горят первые 4 светодиода, при нуле — не горит ни один светодиод (смотрите вложенное видео).

Требования к оформлению: использовать конструкцию  try-finally